<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Carte + Caméra iPhone — Gestes ml5.js</title>

  <!-- Leaflet CSS sans integrity -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #111;
      color: #eee;
    }

    /* Split screen */
    .split {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    #map {
      flex: 1 1 50%;
      height: 100%;
      min-width: 280px;
    }

    .camera-side {
      flex: 1 1 50%;
      position: relative;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    video#video {
      /* Mirror to feel natural for front camera */
      transform: scaleX(-1);
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    canvas#overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 12px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(4px);
    }

    .status {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      text-align: right;
    }

    @media (max-width: 600px) {
      .split { flex-direction: column; }
      #map, .camera-side { height: 50vh; }
    }
  </style>
</head>
<body>
  <div class="split">
    <div id="map"></div>

    <div class="camera-side">
      <div class="hud">
        Gestes: <strong>Poing → Zoom+</strong> | <strong>Paume → Zoom−</strong>
      </div>
      <div class="status" id="status">Chargement modèle...</div>

      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
  </div>

  <!-- Leaflet JS sans integrity -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- p5.js nécessaire pour ml5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

  <!-- ml5.js -->
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <script>
  // === Config ===
  const VIDEO_WIDTH = 640;
  const VIDEO_HEIGHT = 480;
  const OPEN_PALM_THRESHOLD = 0.32;
  const CLOSED_FIST_THRESHOLD = 0.22;
  const SMOOTHING_WINDOW = 6;
  const GESTURE_COOLDOWN_MS = 700;

  // Leaflet setup
  const map = L.map('map').setView([48.8566, 2.3522], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const centerMarker = L.circleMarker(map.getCenter(), {radius:6, color:'#ff5722'}).addTo(map);
  map.on('move', () => {
    centerMarker.setLatLng(map.getCenter());
  });

  // Video & ml5 setup
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const overlayCtx = overlay.getContext('2d');
  const statusEl = document.getElementById('status');

  overlay.width = VIDEO_WIDTH;
  overlay.height = VIDEO_HEIGHT;

  let handposeModel = null;
  let latestPredictions = [];
  let distancesHistory = [];
  let lastActionAt = 0;

  function dist(a, b) {
    const dx = a[0] - b[0];
    const dy = a[1] - b[1];
    return Math.sqrt(dx*dx + dy*dy);
  }

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          width: { ideal: VIDEO_WIDTH },
          height: { ideal: VIDEO_HEIGHT },
          facingMode: "user"
        }
      });
      video.srcObject = stream;
      await video.play();
      overlay.width = video.videoWidth || VIDEO_WIDTH;
      overlay.height = video.videoHeight || VIDEO_HEIGHT;
      statusEl.textContent = "Caméra prête — chargement du modèle...";
    } catch (err) {
      console.error("Erreur caméra:", err);
      statusEl.textContent = "Erreur accès caméra: " + (err.message || err);
    }
  }

  async function loadHandpose() {
    handposeModel = await ml5.handpose(video, () => {
      console.log("handpose ready");
      statusEl.textContent = "Modèle chargé — détecte les gestes...";
    });
    handposeModel.on('hand', results => {
      latestPredictions = results;
    });
  }

  function analyzeHand(landmarks) {
    const wrist = landmarks[0];
    const tipIndices = [4,8,12,16,20];
    const sizeRef = dist(landmarks[0], landmarks[9]) || 1;
    const dists = tipIndices.map(i => dist(landmarks[i], wrist));
    const avg = dists.reduce((a,b) => a+b, 0) / dists.length;
    const normalized = avg / sizeRef;
    return {
      normalizedTipDist: normalized,
      rawTipDists: dists,
      wrist,
      landmarks
    };
  }

  function smoothDistance(value) {
    distancesHistory.push(value);
    if (distancesHistory.length > SMOOTHING_WINDOW) distancesHistory.shift();
    const sum = distancesHistory.reduce((a,b) => a+b, 0);
    return sum / distancesHistory.length;
  }

  function handleGesture(smoothed) {
    const now = Date.now();
    if (now - lastActionAt < GESTURE_COOLDOWN_MS) return;

    if (smoothed < CLOSED_FIST_THRESHOLD) {
      map.zoomIn(1);
      lastActionAt = now;
      statusEl.textContent = "Poing — Zoom +";
    } else if (smoothed > OPEN_PALM_THRESHOLD) {
      map.zoomOut(1);
      lastActionAt = now;
      statusEl.textContent = "Paume — Zoom −";
    } else {
      statusEl.textContent = "Aucun geste net";
    }
  }

  function drawHand(landmarks) {
    const ctx = overlayCtx;
    ctx.clearRect(0,0,overlay.width, overlay.height);
    if (!landmarks) return;
    ctx.save();
    ctx.lineWidth = 2;
    const lines = [
      [0,1,2,3,4],
      [0,5,6,7,8],
      [0,9,10,11,12],
      [0,13,14,15,16],
      [0,17,18,19,20]
    ];
    ctx.strokeStyle = 'rgba(0,150,255,0.9)';
    lines.forEach(segment => {
      ctx.beginPath();
      segment.forEach((i, idx) => {
        const x = overlay.width - landmarks[i][0];
        const y = landmarks[i][1];
        if (idx === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    });
    ctx.fillStyle = 'rgba(255,200,0,0.9)';
    landmarks.forEach(pt => {
      const x = overlay.width - pt[0];
      const y = pt[1];
      ctx.beginPath();
      ctx.arc(x,y,4,0,Math.PI*2);
      ctx.fill();
    });
    ctx.restore();
  }

  function loop() {
    if (video && video.videoWidth) {
      if (overlay.width !== video.videoWidth || overlay.height !== video.videoHeight) {
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
      }
    }

    if (latestPredictions.length > 0) {
      const hand = latestPredictions[0];
      if (hand && hand.landmarks) {
        const analysis = analyzeHand(hand.landmarks);
        const smoothed = smoothDistance(analysis.normalizedTipDist);
        drawHand(hand.landmarks);
        handleGesture(smoothed);
      }
    } else {
      overlayCtx.clearRect(0,0,overlay.width,overlay.height);
      statusEl.textContent = "Aucune main détectée";
    }

    requestAnimationFrame(loop);
  }

  (async () => {
    await startCamera();
    await loadHandpose();
    distancesHistory = [];
    lastActionAt = 0;
    loop();
  })();
  </script>
</body>
</html>
